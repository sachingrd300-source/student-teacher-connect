
/**
 * Core Philosophy: This ruleset enforces a role-based access model for an
 * educational application (EduConnect Pro) with three primary roles: Teacher,
 * Student, and Parent. Authorization is primarily determined by denormalized
 * relationships stored directly within documents (e.g., a `teacherId` field
 * on a student's record) rather than by custom claims or global roles. This
 * allows for efficient and secure access control.
 *
 * Data Structure: The data is organized into a flat structure with top-level
 * collections for each primary entity (`users`, `teachers`, `students`,
 * `parents`, `study_materials`, etc.). This structural segregation ensures that
 * each collection has a clear and homogeneous security posture.
 *
 * Key Security Decisions:
 * - User documents (`/users/{userId}`) are the source of truth for role and
 *   basic info. They can be read by related users (e.g., a teacher can read a
 *   student's user doc) but only written by the owner.
 * - Role-specific profiles (`/teachers/{id}`, etc.) contain data unique to
 *   that role and are managed by the user they belong to.
 * - Shared data like `study_materials` is publicly readable by any signed-in
 *   user but writable only by the creating teacher.
 * - Listing documents is controlled to prevent data enumeration.
 *
 * Denormalization for Authorization: To create simpler, more performant rules,
 * authorization-critical data is denormalized. For example, `teacherId` is
 * copied onto user documents for students. This allows rules to authorize users
 * based on fields in the document they are accessing, avoiding costly `get()`
 * calls where possible.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the wildcard document ID.
     * Used for collections where the document ID is the user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Retrieves the user document for a given userId.
     */
    function getUserDoc(userId) {
      return get(/databases/$(database)/documents/users/$(userId));
    }
    
    /**
     * Retrieves the teacher document using its ID (which is the user's UID).
     */
    function getTeacherDocByUserId(userId) {
      // This assumes a 'teachers' collection where documents might not have the userId as the ID.
      // A query would be more robust, but for direct lookups `get` is needed.
      // This is a placeholder for a more complex lookup if needed.
      // For now, we will assume a way to get from userId to teacher doc.
      // A common pattern is to have a /users/{userId}/teacherProfile doc,
      // or to have the teacher doc ID be the same as the user ID.
      // Let's rely on the `isTeacher(userId)` which checks the user's role.
      return get(/databases/$(database)/documents/teachers/$(userId)); // This may need adjustment based on final structure
    }

    /**
     * Checks if the user with `userId` has the role of 'teacher'.
     */
    function isTeacher(userId) {
      return isSignedIn() && getUserDoc(userId).data.role == 'teacher';
    }
    
     /**
     * Checks if the requesting user is the owner of the teacher document.
     * It compares the `userId` field in the teacher document with the request's auth uid.
     */
    function isTeacherOwner(teacherDoc) {
      return isSignedIn() && request.auth.uid == teacherDoc.data.userId;
    }


    /**
     * Checks if the requesting user is the teacher of a specific student.
     * It reads the student's user document to get the teacherId and checks against the teacher's own ID.
     */
    function isTeacherOfStudent(studentUserId) {
        let studentUserDoc = getUserDoc(studentUserId);
        let teacherId = studentUserDoc.data.teacherId; // This is the ID from the `teachers` collection (verification code)
        if (teacherId == null) {
          return false;
        }
        let teacherDoc = get(/databases/$(database)/documents/teachers/$(teacherId));
        return teacherDoc.data.userId == request.auth.uid;
    }
    
    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description User documents store primary role and identity info.
     * - Owner can create, update, delete.
     * - A teacher can read their approved students' user docs.
     * - A student can read their own user doc.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isTeacherOfStudent(userId);
      allow list: if isTeacher(request.auth.uid); // Teachers can list students under them.
      allow create: if isOwner(userId) || isTeacher(request.auth.uid); // Teachers can create students
      allow update: if isOwner(userId) || (isTeacher(request.auth.uid) && isTeacherOfStudent(userId)); // Teacher can approve student
      allow delete: if isOwner(userId);
    }

    /**
     * @description Teacher profiles contain info specific to the teacher role.
     * - Only the owning user can manage their teacher profile.
     * @path /teachers/{teacherId}
     */
    match /teachers/{teacherId} {
      allow get: if isSignedIn(); // Any signed-in user can read teacher profiles
      allow list: if false; // Prevent listing all teachers
      allow create: if isOwner(getAfter(/databases/$(database)/documents/teachers/$(teacherId)).data.userId);
      allow update, delete: if isOwner(resource.data.userId) && isExistingDoc();
    }

    /**
     * @description Student-specific data.
     * - A user creates their own student profile.
     * - The student and their assigned teacher can read it.
     * - Only the student can delete it.
     * @path /students/{studentId}
     */
    match /students/{studentId} {
      allow get: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId) || isTeacher(request.auth.uid);
      allow update: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId);
      allow delete: if isOwner(resource.data.userId) && isExistingDoc();
    }

    /**
     * @description Parent profiles.
     * @path /parents/{parentId}
     */
    match /parents/{parentId} {
      // Simplified for now - only owner can manage.
      allow get, update, delete: if isOwner(resource.data.userId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId);
    }

    /**
     * @description Study materials are readable by any signed-in user but can only be managed by the teacher who created them.
     * @path /study_materials/{studyMaterialId}
     */
    match /study_materials/{studyMaterialId} {
      allow get, list: if isSignedIn();
      // Allow create/update/delete if the user's UID matches the `userId` of the teacher doc referenced by `teacherId`.
      allow write: if isTeacher(request.auth.uid) && get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.userId == request.auth.uid;
    }

    /**
     * @description Attendance records are managed by teachers. They are readable by the teacher and the associated student.
     * @path /attendances/{attendanceId}
     */
    match /attendances/{attendanceId} {
      allow get: if isTeacherOfStudent(resource.data.studentId) || isOwner(resource.data.studentId);
      allow list: if isSignedIn();
      allow write: if isTeacher(request.auth.uid) && get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.userId == request.auth.uid;
    }

    /**
     * @description Test results are managed by teachers. They are readable by the teacher and the associated student.
     * @path /test_results/{testResultId}
     */
    match /test_results/{testResultId} {
      allow get: if isTeacherOfStudent(resource.data.studentId) || isOwner(resource.data.studentId);
      allow list: if isSignedIn();
      allow write: if isTeacher(request.auth.uid) && get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.userId == request.auth.uid;
    }
    
    /**
     * @description Batches are managed by teachers.
     * @path /batches/{batchId}
     */
    match /batches/{batchId} {
      allow read, list: if isSignedIn();
      // Allow write if user is a teacher and their uid matches the userId in the referenced teacher doc
      allow write: if isTeacher(request.auth.uid) && get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.userId == request.auth.uid;
    }

    /**
     * @description Schedules are managed by teachers.
     * @path /schedules/{scheduleId}
     */
     match /schedules/{scheduleId} {
        allow read, list: if isSignedIn();
        allow write: if isTeacher(request.auth.uid) && get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.userId == request.auth.uid;
     }

  }
}
