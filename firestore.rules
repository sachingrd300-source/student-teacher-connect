
/**
 * Core Philosophy: This ruleset enforces a role-based access model for an
 * educational application (EduConnect Pro) with three primary roles: Teacher,
 * Student, and Parent. Authorization is primarily determined by denormalized
 * relationships stored directly within documents (e.g., a `teacherId` field
 * on a student's record) rather than by custom claims or global roles. This
 * allows for efficient and secure access control.
 *
 * Data Structure: The data is organized into a flat structure with top-level
 * collections for each primary entity (`users`, `teachers`, `students`,
 * `parents`, `study_materials`, etc.). This structural segregation ensures that
 * each collection has a clear and homogeneous security posture.
 *
 * Key Security Decisions:
 * - User documents (`/users/{userId}`) are the source of truth for role and
 *   basic info. They can be read by related users (e.g., a teacher can read a
 *   student's user doc) but only written by the owner.
 * - Role-specific profiles (`/teachers/{id}`, etc.) contain data unique to
 *   that role and are managed by the user they belong to.
 * - Shared data like `study_materials` is publicly readable by any signed-in
 *   user but writable only by the creating teacher.
 * - Listing documents is controlled to prevent data enumeration.
 *
 * Denormalization for Authorization: To create simpler, more performant rules,
 * authorization-critical data is denormalized. For example, `teacherId` is
 * copied onto user documents for students. This allows rules to authorize users
 * based on fields in the document they are accessing, avoiding costly `get()`
 * calls where possible.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the wildcard document ID.
     * Used for collections where the document ID is the user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Retrieves the user document for a given userId.
     */
    function getUserDoc(userId) {
      return get(/databases/$(database)/documents/users/$(userId));
    }

    /**
     * Checks if the user with `userId` has the role of 'teacher'.
     */
    function isTeacher(userId) {
      return isSignedIn() && getUserDoc(userId).data.role == 'teacher';
    }
    
     /**
     * Checks if the requesting user is the owner of the teacher document.
     * It compares the `userId` field in the teacher document with the request's auth uid.
     */
    function isTeacherOwner(teacherDoc) {
      return isSignedIn() && request.auth.uid == teacherDoc.data.userId;
    }


    /**
     * Checks if the requesting user is the teacher of a specific student.
     * It reads the student's user document to get the teacherId and checks against the teacher's own ID.
     */
    function isTeacherOfStudent(studentUserId) {
        let studentUserDoc = getUserDoc(studentUserId);
        // The teacherId on the student's user doc is the ID from the `teachers` collection (the verification code)
        let teacherIdOnStudent = studentUserDoc.data.teacherId; 
        if (teacherIdOnStudent == null) {
          return false;
        }
        // We need to find the teacher doc whose ID is `teacherIdOnStudent` and check if its `userId` matches the requester.
        // This requires a query, which is not possible in rules.
        // A better way is to check the requester's own teacherId.
        let teacherDoc = get(/databases/$(database)/documents/teachers/$(teacherIdOnStudent));
        return teacherDoc.exists && teacherDoc.data.userId == request.auth.uid;
    }

    function isParentOfStudent(studentUserId) {
        // Find the parent document for the requesting user
        let parentDocs = firestore.get(/databases/$(database)/documents/parents?userId=$(request.auth.uid)).docs;
        if (parentDocs.size() == 0) {
            return false;
        }
        let parentDoc = parentDocs[0];
        // Check if the parent's studentId matches the student being accessed
        return parentDoc.data.studentId == studentUserId;
    }
    
    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description User documents store primary role and identity info.
     * - Owner can create, update, delete.
     * - A teacher can read their approved students' user docs.
     * - A student can read their own user doc.
     * - A parent can read their own child's user doc.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isTeacherOfStudent(userId) || isParentOfStudent(userId);
      allow list: if isTeacher(request.auth.uid); // Teachers can list students under them.
      allow create: if isOwner(userId) || isTeacher(request.auth.uid); // Teachers can create students
      allow update: if isOwner(userId) || (isTeacher(request.auth.uid) && isTeacherOfStudent(userId)); // Teacher can approve student
      allow delete: if isOwner(userId);
    }

    /**
     * @description Teacher profiles contain info specific to the teacher role.
     * - Only the owning user can manage their teacher profile.
     * @path /teachers/{teacherId}
     */
    match /teachers/{teacherId} {
      allow get: if isSignedIn(); // Any signed-in user can read teacher profiles
      allow list: if false; // Prevent listing all teachers
      allow create: if isOwner(getAfter(/databases/$(database)/documents/teachers/$(teacherId)).data.userId);
      allow update, delete: if isOwner(resource.data.userId) && isExistingDoc();
    }

    /**
     * @description Student-specific data.
     * - A user creates their own student profile.
     * - The student and their assigned teacher can read it.
     * - Only the student can delete it.
     * @path /students/{studentId}
     */
    match /students/{studentId} {
      allow get: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId) || isParentOfStudent(resource.data.userId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId) || isTeacher(request.auth.uid);
      allow update: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId);
      allow delete: if isOwner(resource.data.userId) && isExistingDoc();
    }

    /**
     * @description Parent profiles.
     * @path /parents/{parentId}
     */
    match /parents/{parentId} {
      // Owner can manage their own profile
      allow get, update, delete: if isOwner(resource.data.userId);
      // Teacher of the linked student can read the parent profile
      allow get: if isTeacherOfStudent(resource.data.studentId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId);
    }

    /**
     * @description Study materials are readable by any signed-in user but can only be managed by the teacher who created them.
     * @path /study_materials/{studyMaterialId}
     */
    match /study_materials/{studyMaterialId} {
      // Allow read if user is signed in
      allow get, list: if isSignedIn();
      // Allow write if user is a teacher and their userId matches the teacherId on the material
      allow write: if isTeacher(request.auth.uid) && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers?userId=$(request.auth.uid)).docs[0].id;
    }


    /**
     * @description Attendance records are managed by teachers. They are readable by the teacher and the associated student/parent.
     * @path /attendances/{attendanceId}
     */
    match /attendances/{attendanceId} {
      allow get: if isTeacher(request.auth.uid) || isOwner(resource.data.studentId) || isParentOfStudent(resource.data.studentId);
      allow list: if isSignedIn();
      allow write: if isTeacher(request.auth.uid) && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers?userId=$(request.auth.uid)).docs[0].id;
    }

    /**
     * @description Test results are managed by teachers. They are readable by the teacher and the associated student/parent.
     * @path /test_results/{testResultId}
     */
    match /test_results/{testResultId} {
      allow get: if isTeacher(request.auth.uid) || isOwner(resource.data.studentId) || isParentOfStudent(resource.data.studentId);
      allow list: if isSignedIn();
      allow write: if isTeacher(request.auth.uid) && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers?userId=$(request.auth.uid)).docs[0].id;
    }
    
    /**
     * @description Batches are managed by teachers.
     * @path /batches/{batchId}
     */
    match /batches/{batchId} {
      allow read, list: if isSignedIn();
      // Allow write if user is a teacher and their userId matches the teacherId on the batch
      allow write: if isTeacher(request.auth.uid) && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers?userId=$(request.auth.uid)).docs[0].id;
    }

    /**
     * @description Schedules are managed by teachers and readable by relevant users.
     * @path /schedules/{scheduleId}
     */
     match /schedules/{scheduleId} {
        allow read, list: if isSignedIn(); // Simplified for now
        allow write: if isTeacher(request.auth.uid) && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers?userId=$(request.auth.uid)).docs[0].id;
     }

  }
}
