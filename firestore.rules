
/**
 * Core Philosophy: This ruleset enforces a role-based access model for an
 * educational application (EduConnect Pro) with three primary roles: Teacher,
 * Student, and Parent. Authorization is primarily determined by denormalized
 * relationships stored directly within documents (e.g., a `teacherId` field
 * on a student's record) rather than by custom claims or global roles. This
 * allows for efficient and secure access control.
 *
 * Data Structure: The data is organized into a flat structure with top-level
 * collections for each primary entity (`users`, `teachers`, `students`,
 * `parents`, `study_materials`, etc.). This structural segregation ensures that
 * each collection has a clear and homogeneous security posture.
 *
 * Key Security Decisions:
 * - User documents (`/users/{userId}`) are the source of truth for role and
 *   basic info. They can be read by related users (e.g., a teacher can read a
 *   student's user doc) but only written by the owner.
 * - Role-specific profiles (`/teachers/{id}`, etc.) contain data unique to
 *   that role and are managed by the user they belong to.
 * - Shared data like `study_materials` is publicly readable by any signed-in
 *   user but writable only by the creating teacher.
 * - Listing documents is controlled to prevent data enumeration.
 *
 * Denormalization for Authorization: To create simpler, more performant rules,
 * authorization-critical data is denormalized. For example, `teacherId` is
 * copied onto user documents for students. This allows rules to authorize users
 * based on fields in the document they are accessing, avoiding costly `get()`
 * calls where possible.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the wildcard document ID.
     * Used for collections where the document ID is the user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Retrieves the user document for a given userId.
     */
    function getUserDoc(userId) {
      return get(/databases/$(database)/documents/users/$(userId));
    }
    
    /**
     * Retrieves the teacher document using its ID (verification code).
     */
    function getTeacherDoc(teacherId) {
        return get(/databases/$(database)/documents/teachers/$(teacherId));
    }

    /**
     * Checks if the requesting user is a 'teacher'.
     */
    function isTeacher() {
      return isSignedIn() && getUserDoc(request.auth.uid).data.role == 'teacher';
    }

    /**
     * Checks if the requesting user is the teacher associated with a given teacherId (verification code).
     */
    function isSpecificTeacher(teacherId) {
        let teacherDoc = getTeacherDoc(teacherId);
        return isSignedIn() && teacherDoc.data.userId == request.auth.uid;
    }
    
    /**
     * Checks if the requesting user is the teacher of a specific student.
     * It reads the student's user document to get the teacherId.
     */
    function isTeacherOfStudent(studentUserId) {
        let studentUserDoc = getUserDoc(studentUserId);
        return studentUserDoc.data.teacherId != null && isSpecificTeacher(studentUserDoc.data.teacherId);
    }
    
    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description User documents store primary role and identity info.
     * - Owner can create, update, delete.
     * - A teacher can read their approved students' user docs.
     * - A student can read their own user doc.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isTeacherOfStudent(userId);
      allow list: if isTeacher(); // Teachers can list students under them.
      allow create: if isOwner(userId) || isTeacher(); // Teachers can create students
      allow update: if isOwner(userId) || (isTeacher() && isTeacherOfStudent(userId)); // Teacher can approve student
      allow delete: if isOwner(userId);
    }

    /**
     * @description Teacher profiles contain info specific to the teacher role.
     * - Only the owning user can manage their teacher profile.
     * @path /teachers/{teacherId}
     */
    match /teachers/{teacherId} {
      allow get: if isSignedIn(); // Any signed-in user can read teacher profiles
      allow list: if false; // Prevent listing all teachers
      allow create: if isOwner(getAfter(/databases/$(database)/documents/teachers/$(teacherId)).data.userId);
      allow update, delete: if isSpecificTeacher(teacherId) && isExistingDoc();
    }

    /**
     * @description Student-specific data.
     * - A user creates their own student profile.
     * - The student and their assigned teacher can read it.
     * - Only the student can delete it.
     * @path /students/{studentId}
     */
    match /students/{studentId} {
      allow get: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId) || isTeacher();
      allow update: if isOwner(resource.data.userId) || isTeacherOfStudent(resource.data.userId);
      allow delete: if isOwner(resource.data.userId) && isExistingDoc();
    }

    /**
     * @description Parent profiles.
     * @path /parents/{parentId}
     */
    match /parents/{parentId} {
      // Simplified for now - only owner can manage.
      allow get, update, delete: if isOwner(resource.data.userId);
      allow list: if false;
      allow create: if isOwner(request.resource.data.userId);
    }

    /**
     * @description Study materials are readable by any signed-in user but can only be managed by the teacher who created them.
     * @path /study_materials/{studyMaterialId}
     */
    match /study_materials/{studyMaterialId} {
      allow get, list: if isSignedIn();
      allow create: if isSpecificTeacher(request.resource.data.teacherId);
      allow update, delete: if isSpecificTeacher(resource.data.teacherId) && isExistingDoc();
    }

    /**
     * @description Attendance records are managed by teachers. They are readable by the teacher and the associated student.
     * @path /attendances/{attendanceId}
     */
    match /attendances/{attendanceId} {
      allow get: if isSpecificTeacher(resource.data.teacherId) || isOwner(getUserDoc(resource.data.studentId).data.userId);
      allow list: if isSignedIn();
      allow create: if isSpecificTeacher(request.resource.data.teacherId);
      allow update, delete: if isSpecificTeacher(resource.data.teacherId) && isExistingDoc();
    }

    /**
     * @description Test results are managed by teachers. They are readable by the teacher and the associated student.
     * @path /test_results/{testResultId}
     */
    match /test_results/{testResultId} {
      allow get: if isSpecificTeacher(resource.data.teacherId) || isOwner(getUserDoc(resource.data.studentId).data.userId);
      allow list: if isSignedIn();
      allow create: if isSpecificTeacher(request.resource.data.teacherId);
      allow update, delete: if isSpecificTeacher(resource.data.teacherId) && isExistingDoc();
    }
    
    /**
     * @description Batches are managed by teachers.
     * @path /batches/{batchId}
     */
    match /batches/{batchId} {
      allow read: if isSpecificTeacher(resource.data.teacherId) || isTeacherOfStudent(request.auth.uid);
      allow list: if isTeacher();
      allow create: if isTeacher() && request.resource.data.teacherId == get(/databases/$(database)/documents/teachers/$(request.resource.data.teacherId)).data.id;
      allow update, delete: if isSpecificTeacher(resource.data.teacherId) && isExistingDoc();
    }

  }
}
